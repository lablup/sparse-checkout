name: 'Sparse checkout action'
description: 'Sparse checkout a git repository'
branding:
  icon: 'minimize-2'
  color: 'gray-dark'
inputs:
  # Sparse checkout
  patterns:
    description: >
      Write a set of patterns to the sparse-checkout file.

      [Learn more about set](https://git-scm.com/docs/git-sparse-checkout#Documentation/git-sparse-checkout.txt-emsetem)
    required: true

  # Same as actions/checkout
  repository:
    description: 'Repository name with owner. For example, snow-actions/sparse-checkout'
    default: ${{ github.repository }}
    required: false

  ref:
    description: >
      The branch, tag or SHA to checkout. When checking out the repository that
      triggered a workflow, this defaults to the reference or SHA for that
      event.  Otherwise, uses the default branch.
    default: ''
    required: false

  token:
    description: >
      Personal access token (PAT) used to fetch the repository. The PAT is configured
      with the local git config, which enables your scripts to run authenticated git
      commands. The post-job step removes the PAT.

      We recommend using a service account with the least permissions necessary.
      Also when generating a new PAT, select the least scopes necessary.

      [Learn more about creating and using encrypted secrets](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets)
    default: ${{ github.token }}
    required: false

  path:
    description: 'Relative path under $GITHUB_WORKSPACE to place the repository'
    default: '.'
    required: false

runs:
  using: composite
  steps:
    - name: Setting up git credential
      uses: de-vri-es/setup-git-credentials@v2
      with:
        credentials: https://git:${{ inputs.token }}@github.com

    - name: Preparing the target directory
      run: |
        echo "::group::Preparing the target clone directory..."
        if [ -n "$DIRECTORY" ]; then
          mkdir -p $DIRECTORY
        fi
        echo "::endgroup::"
        echo "::group::Git version info"
        git version
        echo "::endgroup::"
      env:
        DIRECTORY: ${{ inputs.path }}
      shell: bash

    - name: Cloning the repository
      run: |
        echo "::group::Cloning the repository"
        git clone --filter=blob:none --no-checkout "${GITHUB_SERVER_URL}/${REPOSITORY}" .
        echo "::endgroup::"
        echo "::group::Disabling automatic garbage collection"
        git config --local gc.auto 0
        echo "::endgroup::"
        echo "::group::Setting up sparse checkout"
        echo "checkout patterns: $PATTERNS"
        git sparse-checkout init --cone
        git sparse-checkout set $PATTERNS
        # To checkout PR merge commits auto-generated by GitHub,
        # map their refspec pattern to valid branch names.
        git config --local --add remote.origin.fetch '+refs/pull/*/merge:refs/remotes/origin/pr-merge/*'
        echo "::endgroup::"
        echo "::group::Checking out the ref"
        echo "repo: $REPOSITORY"
        if [ -z "$REF" ]; then
          echo "ref: $GITHUB_REF (auto)"
          if [ "$REPOSITORY" == "$GITHUB_REPOSITORY" ]; then
            # Convert refspec to branch names.
            [[ $GITHUB_REF =~ "^refs/pull/([[:digit:]]+)/merge$" ]] && echo "${GITHUB_REF/${BASH_REMATCH[1]}/pr-merge/${BASH_REMATCH[2]}}" || echo "fallback: $REF"
            [[ $GITHUB_REF =~ "^refs/heads/(.+)$" ]] && echo "${GITHUB_REF/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}}" || echo "fallback: $REF"
            [[ $GITHUB_REF =~ "^refs/pull/([[:digit:]]+)/merge$" ]] && export BRANCH=${GITHUB_REF/${BASH_REMATCH[1]}/pr-merge/${BASH_REMATCH[2]}} || export BRANCH=$REF
            [[ $GITHUB_REF =~ "^refs/heads/(.+)$" ]] && export BRANCH=${GITHUB_REF/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}} || export BRANCH=$REF
          else
            # TODO: support customization of the ref in remote repos
            BRANCH=$(gh api repos/$REPOSITORY --jq '.default_branch')
          fi
        else
          echo "ref: $REF (configured)"
          [[ $REF =~ "^refs/pull/([[:digit:]]+)/merge$" ]] && export BRANCH=${REF/${BASH_REMATCH[1]}/pr-merge/${BASH_REMATCH[2]}} || export BRANCH=$REF
          [[ $REF =~ "^refs/heads/(.+)$" ]] && export BRANCH=${REF/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}} || export BRANCH=$REF
        fi
        echo "branch: $BRANCH"
        git fetch  # to recognize the branch names
        git checkout --force -B "$BRANCH" "refs/remotes/origin/$BRANCH"
        echo "::endgroup::"
        echo "::group::Logging the commit SHA"
        git log -1 --format='%H'
        echo "::endgroup::"
      env:
        PATTERNS: ${{ inputs.patterns }}
        REF: ${{ inputs.ref }}
        REPOSITORY: ${{ inputs.repository }}
        GH_TOKEN: ${{ inputs.token }}
      working-directory: ${{ inputs.path }}
      shell: bash
